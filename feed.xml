<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Syna&#x27;s blog</title>
    <link href="https://crazyyx.github.io/feed.xml" rel="self" />
    <link href="https://crazyyx.github.io" />
    <updated>2025-11-04T18:31:52+08:00</updated>
    <author>
        <name>Syna</name>
    </author>
    <id>https://crazyyx.github.io</id>

    <entry>
        <title>简单链表和双向链表</title>
        <author>
            <name>Syna</name>
        </author>
        <link href="https://crazyyx.github.io/linked-list.html"/>
        <id>https://crazyyx.github.io/linked-list.html</id>

        <updated>2025-11-04T18:07:27+08:00</updated>
            <summary>
                <![CDATA[
                    链表 一种通过指针连接多个结构体的动态数据结构，兼具灵活性与效率：支持动态扩展与快速的插入删除，但随机访问性能较差。 定义： typedef&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h1 id="链表">链表</h1>
<p>一种通过指针连接多个结构体的动态数据结构，兼具灵活性与效率：支持动态扩展与快速的插入删除，但随机访问性能较差。</p><p>定义：</p><pre><code class="language-cpp">typedef struct L
{
 int num;
 struct L* next;
}Node;
</code></pre>
<p><code>num</code>存储元素，指针变量<code>next</code>存储链表中下一个节点的地址，从而实现逐个遍历。</p><p>当然可以存其他或者多个变量，链表的重点在于那个<code>next</code></p><p>一些常用的函数：</p><ul>
<li><code>create()</code>：创建链表</li>
</ul>
<pre><code class="language-cpp">//创建长度为n的链表
Node* create()
{
    Node *head=NULL,*tail=NULL,*newNode;
    for (int i=1; i&lt;=n; i++)
    {
        int k;
        cin&gt;&gt;k;
        newNode=(Node*)malloc(sizeof(Node));//为新节点分配空间
        newNode-&gt;num=k;
        newNode-&gt;next=NULL;
        if (head==NULL)//即判断当前节点是否为第一个
        {
            head=newNode;
            tail=newNode;//将head和tail都先赋值为第一个节点的地址
        }
        else
        {
            tail-&gt;next=newNode;//tail存储连接新节点前，最后一个节点的地址，这里相当于连接操作
            tail=newNode;//然后移动tail到最新的尾节点
        }
    }
    return head;//一定要保存第一个节点的地址！！这个丢了整个链表就mygo了
}
</code></pre>
<ul>
<li><code>print(Node* head)</code>：顺序输出链表元素</li>
</ul>
<pre><code class="language-cpp">void print(Node* head)
{
    Node* p=head;
    while (p!=NULL)
    {
        cout &lt;&lt;(p-&gt;num)&lt;&lt;‘ ‘;
        p=p-&gt;next;
    }
    return;
}
</code></pre>
<ul>
<li><code>freelist(Node* head)</code>：释放整个链表。 <em>使用完不进行释放操作相当于这几块内存永远被占用，无法被再次使用，也无法被回收。</em> 虽然现在的编译器一般都会在运行后自动释放占用的内存，但以防万一，代码最后写上也没啥。美名曰好习惯</li>
</ul>
<pre><code class="language-cpp">void freelist(Node* head)
{
    Node* p=head;
    while (p!=NULL)
    {
        Node* tmp=p;
        p=p-&gt;next;
        free(tmp);//自带函数，可释放通过malloc()代码分配的内存
    }
    return;
}
</code></pre>
<ul>
<li><code>find（Node* head,int n)</code>：寻找链表中值为<code>n</code>的节点，并返回其地址</li>
</ul>
<pre><code class="language-cpp">//这里以返回第一个值为n的节点地址为例
Node* find(Node* head,int N)
{
    Node* p=head;
    while (p!=NULL)
    {
        if (p-&gt;num==N)
        {
            return p;
        }
        p=p-&gt;next;//继续遍历下一个节点，链表里最常用的一行代码
    }
    return NULL;//若遍历完未找到n，则返回空地址
}
</code></pre>
<ul>
<li><code>add(Node* head,int n,int m)</code>：插入函数，以将新元素<code>n</code>插入第<code>m</code>个位置<strong>后</strong>为例</li>
</ul>
<pre><code class="language-cpp">void add(Node* head,int N,int m)
{
    Node* p=head;
    for (int i=1; i&lt;=m-1; i++)
    {
        p=p-&gt;next;
    }//从head开始，移动m个节点，出循环后p存储第m个节点的地址
    Node* newNode;
    newNode=(Node*)malloc(sizeof(Node));//为新节点分配空间
    newNode-&gt;num=n;
    newNode-&gt;next=p-&gt;next;//将新节点的next赋值为第m+1个节点的地址
    p-&gt;next=newNode;//将第m个节点的next赋值为新节点地址
    //也就是前后各进行一次连接操作，即可实现将新节点插入链表
    return;
}
</code></pre>
<ul>
<li><code>delete(Node* head,int cnt)</code>：删除列表中第<code>cnt</code>个节点</li>
</ul>
<pre><code class="language-cpp">Node* delete(Node* head,int cnt)
{
    Node* HEAD=head;//先存下head，因为删除的节点是第一个时head会发生变化
    Node* p=head;
    for (int i=1; i&lt;=cnt; i++)
    {
        p=p-&gt;next;
    }//将p向后移动cnt位，找到要删除的节点
    if (p==head)//判断要移动的是否是第一个节点
    {
        HEAD=head-&gt;next;//更新HEAD为下一个节点的地址
    }
    pre-&gt;next=target-&gt;next;//核心代码。将目标节点的上一个节点与下一个节点连接,就是把中间那个断开了
    return HEAD;//返回可能发生变动的head
}
</code></pre>
<ul>
<li><code>move(Node* head,int x,int cnt)</code>：移动链表中的节点，以将<strong>存储</strong>元素<code>x</code>的节点向后移动<code>cnt</code>位为例</li>
</ul>
<p>其实几乎就是<code>add</code>加<code>delete</code></p><pre><code class="language-cpp">//这里默认移动cnt位后不会超过链表末尾，不进行防御性编程和特判
Node* move(Node* head,int x,int cnt)
{
    Node* HEAD=head;//先存下head，因为移动操作后可能发生变化
    Node* target=find(head,x);//参考上文的find函数，返回值为x的节点的地址
    Node* pre=pre;//注意为了之后断开的操作，这里还需要记录目标节点前一个节点的地址。可以通过在find函数中加上记录上一个节点地址来实现，也可以更简单的实现：双向链表，下面会介绍。这里不详写实现代码，暂以pre代表target上一个节点的地址
    if (target==head)//判断要移动的是否是第一个节点
    {
        HEAD=head-&gt;next;//更新HEAD为下一个节点的地址
    }//其他情况head都不会发生变化。
    Node* p=target;
    for (int i=1; i&lt;=cnt; i++)
    {
        p=p-&gt;next;
    }//将p向后移动cnt位，循环结束后p存储要移动的节点后cnt个节点的地址
    //移动分为两个操作：将原节点从链表断开，插入一个新节点到链表中。
    pre-&gt;next=target-&gt;next;//断开操作，将目标节点的上一个节点与下一个节点连接就行
    //插入新节点与前文add()函数几乎相同
    target-&gt;next=p-&gt;next;
    p-&gt;next=target;
    return HEAD;//依旧返回新head。要注意在每一个可能造成head变动的函数都进行新head的记录与返回
}
</code></pre>
<p>到这里大家大概也发现了不管什么操作，只要是需访问链表的操作，都要从<code>head</code>开始遍历，导致查找效率低。这就是链表的缺点之一，也是为什么时刻更新、存储<code>head</code>地址如此重要的原因。</p><p>回到上文提到的<code>move</code>操作。向后移动节点固然简单，可是如果要<em>向前</em>移动节点，实现就较为困难了。我们当前的链表，顺序遍历好实现，倒序遍历又该如何实现？针对这个，我们有一个较为便利的解决方法：</p><h2 id="双向链表">双向链表</h2>
<p>如果单向链表可以这么表示的话，</p><pre><code class="language-mermaid">flowchart LR
    classDef default fill:#263238,stroke:#00bcd4,stroke-width:2px,color:#fff
    classDef pointer fill:#37474f,stroke:#ff9800,stroke-width:2px,color:#fff
    
    direction LR
    
    Head[头指针 Head]
    Null[NULL]
    
    N1[数据: 10]
    N2[数据: 20]
    N3[数据: 30]
    
    Head -.-&gt;|指向| N1
    N1 --&gt;|next| N2
    N2 --&gt;|next| N3
    N3 --&gt;|next| Null
    
    class Head,Null pointer
</code></pre>
<p>那么双向链表便是这样子的。</p><pre><code class="language-mermaid">flowchart LR
    classDef default fill:#263238,stroke:#00bcd4,stroke-width:2px,color:#fff
    classDef pointer fill:#37474f,stroke:#ff9800,stroke-width:2px,color:#fff
    classDef null fill:#d32f2f,stroke:#ff5252,stroke-width:2px,color:#fff
    
    direction LR
    
    Head[头指针 Head]
    Tail[尾指针 Tail]
    
    N1[数据: 10]
    N2[数据: 20]
    N3[数据: 30]
    
    Head -.-&gt;|指向| N1
    Tail -.-&gt;|指向| N3
    
    N1 &lt;---&gt;|next/prev| N2
    N2 &lt;---&gt;|next/prev| N3
    
    class Head,Tail pointer
    class Null1,Null2 null
</code></pre>
<p>通过和用<code>next</code>标记下一个节点地址相同的方式，添加一个标记<em>上一个</em>节点地址的变量<code>prev</code>，以实现链表的双向遍历。</p><p>定义：</p><pre><code class="language-cpp">typedef struct L
{
 int num;
 struct L* next;
 struct L* prev;
}Node;
</code></pre>
<p>为了维护新的<code>prev</code>指针，我们需要进行对<code>create()</code>函数的一些小修改。</p><pre><code class="language-cpp">Node* create()
{
    Node *head=NULL,*tail=NULL,*newNode;
    for (int i=1; i&lt;=n; i++)
    {
        int k;
        cin&gt;&gt;k;
        newNode=(Node*)malloc(sizeof(Node));
        newNode-&gt;num=k;
        newNode-&gt;next=NULL;
        newNode-&gt;prev=tail;//记录上一个节点的地址
        if (head==NULL)
        {
            head=newNode;
            tail=newNode;
        }
        else
        {
            tail-&gt;next=newNode;
            tail=newNode;
        }
    }
    return head;
}
</code></pre>
<p>上面的代码没有记录最后的<code>tail</code>，但是双向遍历，此时的<code>tail</code>地位与<code>head</code>一样重要。记录很简单，可以通过指针或者其他方法记录，<del>主要是我懒得改了</del></p><p>应用不需要再说什么了。除了名字不一样，<code>tail</code>和<code>*prev</code>本质上是等效于<code>head</code>和<code>*next</code>的。一些原来反向难以实现的操作可以通过这组反向的指针实现，唯一需要注意的是每一次维护<code>next</code>的操作基本都需要多维护一个<code>prev</code></p><p>-——</p><h2 id="例题">例题</h2>
<ol>
<li>输入一个链表，<strong>以输入<code>-1</code>为结束标志</strong>，逆序输出该链表。</li>
</ol>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
int n,m;
typedef struct LinkNode
{
    int num;
    struct LinkNode* pre;
    struct LinkNode* next;
}Node;
Node *create()
{
    Node *head=NULL,*tail=NULL,*newNode;
    while (1)
    {
        int i;
        scanf(&quot;%d&quot;,&amp;i);
        if (i==-1)
        {
            break;
        }
        newNode=(Node*)malloc(sizeof(Node));
        newNode-&gt;num=i;
        newNode-&gt;next=NULL;
        newNode-&gt;pre=tail;
        if (head==NULL)
        {
            head=newNode;
            tail=newNode;
        }
        else
        {
            tail-&gt;next=newNode;
            tail=newNode;
        }
    }
    return tail;//因为只需要倒序输出，所以只记录tail也没关系
}
void print(Node *head)
{
    Node *p=head;
    while (p!=NULL)
    {
        printf(&quot;%d &quot;,p-&gt;num);
        p=p-&gt;pre;
    }
    return;
}
void freeL(Node *head)
{
    Node *p=head;
    while (p!=NULL)
    {
        Node *temp=p;
        p=p-&gt;next;
        free(temp);
    }
}
int main()
{
    Node* tail=create();
    print(tail);
    return 0;
}
</code></pre>
<ol start="2">
<li>查找链表中的特定元素并移动位置。</li>
</ol>
<p>第一行输入一个正整数 $n(n &gt; 0)$ ，表示链表的长度。</p><p>第二行输入一个正整数$m(m &gt; 0)$，表示移动链表中节点的次数。</p><p>接下来$m$行，每行输入两个整数 $p$ 和 $q$（$q$可为任意负数，$0$，正数 ），分别表示$num$为 $p$ 的节点在链表中移动 $q$ 步。$q$ 为负数表示向前移动。</p><p><strong>注意：移动的距离如果超出链表长度，则放在两端即成为头节点或者成为尾结点。</strong></p><pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
int n,m;
typedef struct LinkNode
{
    int num;
    struct LinkNode* pre;
    struct LinkNode* next;
}Node;
Node *create()
{
    Node *head=NULL,*tail=NULL,*newNode;
    for (int i=1; i&lt;=n; i++)
    {
        newNode=(Node*)malloc(sizeof(Node));
        newNode-&gt;num=i;
        newNode-&gt;next=NULL;
        newNode-&gt;pre=tail;
        if (head==NULL)
        {
            head=newNode;
            tail=newNode;
        }
        else
        {
            tail-&gt;next=newNode;
            tail=newNode;
        }
    }
    return head;
}
void print(Node *head)
{
    Node *p=head;
    while (p!=NULL)
    {
        printf(&quot;%d &quot;,p-&gt;num);
        p=p-&gt;next;
    }
    return;
}
void freeL(Node *head)
{
    Node *p=head;
    while (p!=NULL)
    {
        Node *temp=p;
        p=p-&gt;next;
        free(temp);
    }
}
int getlen(Node *head)
{
    int CNT=0;
    Node *p=head;
    while(p!=NULL)
    {
        CNT++;
        p=p-&gt;next;
    }
    return CNT;
}
Node *find(Node *head,int x)
{
    Node *p=head;
    while (p!=NULL)
    {
        if (p-&gt;num==x)
        {
            return p;
        }
        // *He=p;
        p=p-&gt;next;
    }
    return NULL;
}
Node *move(Node *head,int x,int cnt)
{
    //tarH:目标节点上一个节点的地址//换双向链表了。不用这个记了
    //tarT:目标节点地址
    // Node *tarH=NULL;
    Node *tarT=find(head,x);
    int Len=getlen(tarT);
    if (tarT-&gt;pre==NULL)//目标节点是第一个
    {
        head=tarT-&gt;next;
    }
    // tarH-&gt;next=tarT-&gt;next;
    else
    {
        tarT-&gt;pre-&gt;next=tarT-&gt;next;
    }
    if (tarT-&gt;next!=NULL)
    {
        tarT-&gt;next-&gt;pre=tarT-&gt;pre;
    }
    // tarT-&gt;pre=NULL;
    // tarT-&gt;next=NULL;
   //已经独立出来要移动的节点（将上一个的next连接到下一个，将本节点的next清空）
    if (cnt&gt;0)
    {
        if (cnt&gt;=Len)
        {
            Node *end=head;
            while(end-&gt;next!=NULL)
            {
                end=end-&gt;next;
            }//出来后end就是结尾节点地址了
            end-&gt;next=tarT;//相当于在最后连上目标节点
            tarT-&gt;pre=end;
            tarT-&gt;next=NULL;
        }
        else
        {
            Node *end=tarT;
            for (int i=1; i&lt;=cnt; i++)
            {
                end=end-&gt;next;
            }//end是移动了n步后目标节点前面的那个节点地址
            tarT-&gt;next=end-&gt;next;//end的下一个给目标节点的下一个
            end-&gt;next=tarT;//end下一个给目标节点
            tarT-&gt;pre=end;
        }
    }
    if (cnt&lt;0)
    {
        cnt=-cnt;
        if (cnt&gt;=n-Len-1)
        {
            head-&gt;pre=tarT;
            tarT-&gt;next=head;
            head=tarT;
            tarT-&gt;pre=NULL;
        }
        else
        {
            Node *end=tarT;
            for (int i=1; i&lt;=cnt; i++)
            {
                end=end-&gt;pre;
            }
            end-&gt;pre-&gt;next=tarT;
            tarT-&gt;pre=end-&gt;pre;
            end-&gt;pre=tarT;
            tarT-&gt;next=end;
        }
    }
    return head;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    Node* head=create();
    for (int i=1; i&lt;=m; i++)
    {
        int t1,t2;
        scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2);
        head=move(head,t1,t2);
        // print(head);
    }
    print(head);
    return 0;
}
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Codeforces Round 1062 (Div. 4)</title>
        <author>
            <name>Syna</name>
        </author>
        <link href="https://crazyyx.github.io/codeforces-round-1062-div-4.html"/>
        <id>https://crazyyx.github.io/codeforces-round-1062-div-4.html</id>

        <updated>2025-11-02T18:37:42+08:00</updated>
            <summary>
                <![CDATA[
                    [比赛题目网址][https://codeforces.com/contest/2167] 判断四个木棒是否能够组成正方形。 写的时候第一眼看成长方形了 附赛时代码&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>[比赛题目网址][<a href="https://codeforces.com/contest/2167%5D">https://codeforces.com/contest/2167]</a></p><!--more-->

<hr>
<h3 id="a-square">A. Square?</h3>
<p><strong>判断四个木棒是否能够组成正方形。</strong> 写的时候第一眼看成长方形了
附赛时代码</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int t;
    cin&gt;&gt;t;
    for (int T=1; T&lt;=t; T++)
    {
        int a[10];
        cin&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]&gt;&gt;a[4];
        sort (a+1,a+5);
        if (a[1]==a[2] &amp;&amp; a[3]==a[4] &amp;&amp; a[2]==a[3])
        {
            cout &lt;&lt;&quot;YES&quot;&lt;&lt;endl;
        }
        else
        {
            cout &lt;&lt;&quot;NO&quot;&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<hr>
<h3 id="b-your-name">B. Your Name</h3>
<p><strong>给定两个等长字符串，判断一个字符串是否能够通过改变字符顺序得到另一个。</strong></p><p>比赛时有两个思路，因为题目已经限定字符串只含小写字母，所以可以去存每个字母的出现次数后一一比较；第二个想到后更好实现，就是用<code>sort</code>函数去先给两个字符串进行排序，这种情况下函数会自动按字典序排序字符串。之后只需比较排序后的字符串即可</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int t;
    cin&gt;&gt;t;
    for (int T=1; T&lt;=t; T++)
    {
        int n;
        cin&gt;&gt;n;
        char s[30],w[30];
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;s[i];
        }
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;w[i];
        }
        sort (s+1,s+n+1);
        sort (w+1,w+n+1);
        int b=1;
        for (int i=1; i&lt;=n; i++)
        {
            if (s[i]!=w[i])
            {
                cout &lt;&lt;&quot;NO&quot;&lt;&lt;endl;
                b=0;
                break;
            }
        }
        if (b==1)
        {
            cout &lt;&lt;&quot;YES&quot;&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<hr>
<h3 id="c-isamatdin-and-his-magic-wand">C. Isamatdin and His Magic Wand!</h3>
<p><strong>给定一串数，可以选定一个奇数一个偶数对数字进行交换，求若干次操作后数组能达到的最小字典序的状态。</strong></p><p>注意到如果这个数组含奇数和偶数，那么其实每两个数都是可以通过一个奇偶性不同的“媒介”来实现位置交换的。所以这道题其实就变成了判断数组，如果全奇或全偶则原样输出；否则直接排序后输出。因为这样的操作一定可以达到理论最小字典序。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int t,a[200010];
    cin&gt;&gt;t;
    for (int T=1; T&lt;=t; T++)
    {
        int n,b1=0,b2=0;
        cin&gt;&gt;n;
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;a[i];
            if (a[i]%2==0)
            {
                b2=1;
            }
            else
            {
                b1=1;
            }
        }
        if (b2==1 &amp;&amp; b1==1)
        {
            sort(a+1,a+n+1);
        }
        for (int i=1; i&lt;=n; i++)
            {
                cout &lt;&lt;a[i]&lt;&lt;&#39; &#39;;
            }
        cout &lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<hr>
<h3 id="d-yet-another-array-problem">D. Yet Another Array Problem</h3>
<p><strong>给定一个数组，要求找出和其中至少一个数互质的数，输出符合条件的最小数。没有则输出-1</strong></p><p>虽然题目的范围给的很大 $( 2 \leq x,a_i \leq 10^{18} )$ ，但是再想一下不难发现前几十个质数相乘就已经远远超过这个大小了。（好像乘到57左右）那么，理论上这个题的答案也不会超过这个数。我是只处理了小于100的质数，后面就偏暴力枚举了，事实证明100以内就够了。
所以应该就不存在不存在这样的数，最终输出-1的情况。<del>想搓组数据去hack的时候才察觉到这一点</del></p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    unsigned long long t,a[100010];
    int b[110]={0};
    cin&gt;&gt;t;
    for (int i=3; i&lt;=100; i++)
    {
        for (int j=i-1; j&lt;=2; j++)
        {
            if (i%j==0)
            {
                b[i]=1;
                break;
            }
        }
    }
    for (int T=1; T&lt;=t; T++)
    {
        int n,b1=0,b2=0;
        cin&gt;&gt;n;
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;a[i];
        }
        int bb=0;
        for (int i=2; i&lt;=100; i++)
        {
            if (b[i]==0)
            {
                for (int j=1; j&lt;=n; j++)
              {
                    if (gcd(i,a[j])==1)
                    {
                        cout &lt;&lt;i&lt;&lt;endl;
                        bb=1;
                        break;
                    }
                }
            }
            if (bb==1)
            {
                break;
            }
        }
        if (bb==0)
        {
            cout &lt;&lt;-1&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<hr>
<h3 id="e-khba-loves-to-sleep">E. khba Loves to Sleep!</h3>
<p><strong>在$[0,x]$范围里，$n$个朋友分别位于位置$a_i$，要求选定$k$个位置，使这些朋友到达其中任何一个位置的最小距离最大。</strong></p><p>题目范围$1 \leq n,k \leq 2 \cdot 10^5,k-1 \leq x \leq 10^9$，遍历一边整个范围的位置代价过于大了，$k$的不定导致没法从相邻朋友的距离这个方面入手。
考虑二分答案（这里的“答案”即最大的最小距离），对于每个答案遍历一遍满足这个距离的时候，所有的可行位置$sum$，之后将其与$k$进行比较。$sum &lt; k$时说明目前答案已经不可行了，继续二分前半段更小的最小距离；$sum \geq k$则说明当前答案可以，继续二分更大的答案。
比赛的时候猪脑过载写了一堆好像也不用特判的判断。出D题才0:22，出这道题就1:24了。仅供参考，看前面的二分代码就行</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int t,a[200010];
    cin&gt;&gt;t;
    for (int T=1; T&lt;=t; T++)
    {
        int n,k,x;
        cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;a[i];
        }
        // if (n==1)//这是笨比特判，后来发现没用，别看
        // {
        //     int as;
        //     if (abs(x-a[1]-a[1])&gt;=k)
        //     {
        //         as=min(x-a[1],a[1]);
        //     }
        //     else
        //     as=min(x-a[1],a[1])-(k-abs(x-a[1]-a[1]))/2;
        //     int aaa=0;
        //     cout&lt;&lt;&quot;S&quot;&lt;&lt;as&lt;&lt;endl;
        //     for (int i=0; i&lt;=x; i++)
        //     {
        //         if (i&lt;=a[1]-as+1  || i&gt;=a[1]+as-1)
        //         {
        //             if (aaa==k)
        //             {
        //                 break;
        //             }
        //             cout &lt;&lt;i&lt;&lt;&quot; &quot;;
        //             aaa++;
        //         }
        //     }
        //     cout &lt;&lt;endl;
        //     break;
        // }
        sort (a+1,a+n+1);
        int l=0,r=x+2;
        int rr,br=0;
        while (l&lt;=r)
        {
            int mid=(l+r)/2,ans=0;
            if (a[1]-mid+1&gt;0)
            {
                ans+=a[1]-mid+1;
            }
            // cout &lt;&lt;l&lt;&lt;&#39;,&#39;&lt;&lt;r&lt;&lt;endl;
            for (int i=2; i&lt;=n; i++)
            {
                // cout &lt;&lt;a[i]&lt;&lt;&quot;__&quot;&lt;&lt;a[i-1]&lt;&lt;&quot;:&quot;&lt;&lt;a[i]-mid+1-a[i-1]-mid&lt;&lt;endl;
                if (a[i]-mid+1-a[i-1]-mid&gt;0)
                {
                    ans+=a[i]-mid+1-a[i-1]-mid;
                }
            }
            if (x-a[n]-mid+1&gt;0)
            {
                ans+=x-a[n]-mid+1;
            }
            // cout &lt;&lt;&quot;**&quot;&lt;&lt;ans&lt;&lt;endl;
            if (ans&gt;=k)
            {
                rr=mid;
                if (l==r)
            {
                break;
            }
                if (r-l==1)
                {
                    br=1;
                    l=r;
                    continue;
                }
                l=mid;
                continue;
            }
            if (l==r)
            {
                break;
            }
            r=mid;
        }
        // cout&lt;&lt;&quot;ANS=&quot;&lt;&lt;rr&lt;&lt;endl&lt;&lt;endl;
        if (rr==0)
        {
            for (int i=0; i&lt;=k-1; i++)
            {
                cout &lt;&lt;i&lt;&lt;&#39; &#39;;
            }
            cout &lt;&lt;endl;
            continue;
        }
            int aa=0;
            if (a[1]-rr&gt;=0)
            {
                for (int j=0; j&lt;=a[1]-rr; j++)
                {
                    if (aa==k)
                    {
                        break;
                    }
                    cout &lt;&lt;j&lt;&lt;&#39; &#39;;
                    aa++;
                }
            }
            if (aa&lt;k)
            {
                for (int i=2; i&lt;=n; i++)
            {
                if (a[i]-rr+1-a[i-1]-rr&gt;0)
                {
                    for (int j=a[i-1]+rr; j&lt;=a[i]-rr; j++)
                    {
                        if (aa==k)
                        {
                            break;
                        }
                        cout &lt;&lt;j&lt;&lt;&#39; &#39;;
                        aa++;
                    }
                }
                if (aa==k)
                        {
                            break;
                        }
            }
                if (aa&lt;k)
                {
                    if (x-a[n]-rr+1&gt;0)
            {
                for (int j=a[n]+rr; j&lt;=x; j++)
                {
                    if (aa==k)
                    {
                        break;
                    }
                    cout &lt;&lt;j&lt;&lt;&#39; &#39;;
                    aa++;
                }
            }
                }
            }

            cout &lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<hr>
<h3 id="f-tree-tree">F. Tree, TREE!!!</h3>
<p>等我钻研一下之后可能补上。枚举每个根节点的lca显然会超时，应该是树状dp之类的东西，但是我忘了咋写了</p><hr>
<h3 id="g-mukhammadali-and-the-smooth-array">G. Mukhammadali and the Smooth Array</h3>
<p><strong>给定一个数组$a_n$，可以进行操作：消耗代价$c_i$，将$a_i$更改为任意数。求最小的代价，将整个数组变为不严格递增数列（即可以存在相等的数）。</strong></p><p>dp。定义dp数组$dp_i$为到如使$a_i$不变，到第$i$个位置为止，保证前面是不严格递增所<strong>节省的</strong>代价的<strong>最大值</strong>。
实现：</p><ul>
<li>先初始化$dp_i=c_i$，即初始不变$a_i$时节省的代价是$c_i$本身；</li>
<li>枚举$i$。对于每个$i$，枚举所有$j&lt;i$，若有$a_j \leq a_i$，则执行状态转移方程
$$
dp_i=max(dp_i,dp_j+c_i)
$$
意思大概就是$a_j \leq a_i$时，$a_j$与$a_i$已经满足不严格递增，可以在到第$j$个位置为止节省的代价的基础上（即$dp_j$）再节省一个$c_i$，$dp_i$取从$j$转移过来的和它当时本身的最大值即可。</li>
<li>取所有$dp_i$中的最大值$dp_{max}$。因为代价最小和节省的代价最大等价，输出$\sum_{i=1}^{n} c_i-dp_{max}$即为最终答案。</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int t;
    cin&gt;&gt;t;
    for (int T=1; T&lt;=t; T++)
    {
        long long sum=0;
        long long n,a[10000],c[10000],dp[10000];
        cin&gt;&gt;n;
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;a[i];
        }
        for (int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;c[i];
            sum+=c[i];
            dp[i]=c[i];
        }
        for (int i=1; i&lt;=n; i++)
        {
            for (int j=1; j&lt;i; j++)
            {
                if (a[j]&lt;=a[i])
                {
                    dp[i]=max(dp[i],dp[j]+c[i]);
                }
            }
        }
        long long mx=-1;
        for (int i=1; i&lt;=n; i++)
        {
            mx=max(mx,dp[i]);
        }
        // cout &lt;&lt;&quot;++&quot;;
        cout &lt;&lt;sum-mx&lt;&lt;endl;
    }
    return 0;
}
</code></pre>

            ]]>
        </content>
    </entry>
</feed>
