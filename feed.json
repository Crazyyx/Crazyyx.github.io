{
    "version": "https://jsonfeed.org/version/1",
    "title": "Syna&#x27;s blog",
    "description": "",
    "home_page_url": "https://crazyyx.github.io",
    "feed_url": "https://crazyyx.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Syna"
    },
    "items": [
        {
            "id": "https://crazyyx.github.io/codeforces-round-1062-div-4.html",
            "url": "https://crazyyx.github.io/codeforces-round-1062-div-4.html",
            "title": "Codeforces Round 1062 (Div. 4)",
            "summary": "比赛题目网址 https://codeforces.com/contest/2167 判断四个木棒是否能够组成正方形。 写的时候第一眼看成长方形了&hellip;",
            "content_html": "<p>比赛题目网址\n<a href=\"https://codeforces.com/contest/2167\">https://codeforces.com/contest/2167</a></p><!--more-->\n\n<hr>\n<h3 id=\"a-square\">A. Square?</h3>\n<p><strong>判断四个木棒是否能够组成正方形。</strong> 写的时候第一眼看成长方形了\n附赛时代码</p><pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int t;\n    cin&gt;&gt;t;\n    for (int T=1; T&lt;=t; T++)\n    {\n        int a[10];\n        cin&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]&gt;&gt;a[4];\n        sort (a+1,a+5);\n        if (a[1]==a[2] &amp;&amp; a[3]==a[4] &amp;&amp; a[2]==a[3])\n        {\n            cout &lt;&lt;&quot;YES&quot;&lt;&lt;endl;\n        }\n        else\n        {\n            cout &lt;&lt;&quot;NO&quot;&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"b-your-name\">B. Your Name</h3>\n<p><strong>给定两个等长字符串，判断一个字符串是否能够通过改变字符顺序得到另一个。</strong></p><p>比赛时有两个思路，因为题目已经限定字符串只含小写字母，所以可以去存每个字母的出现次数后一一比较；第二个想到后更好实现，就是用<code>sort</code>函数去先给两个字符串进行排序，这种情况下函数会自动按字典序排序字符串。之后只需比较排序后的字符串即可</p><pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int t;\n    cin&gt;&gt;t;\n    for (int T=1; T&lt;=t; T++)\n    {\n        int n;\n        cin&gt;&gt;n;\n        char s[30],w[30];\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;s[i];\n        }\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;w[i];\n        }\n        sort (s+1,s+n+1);\n        sort (w+1,w+n+1);\n        int b=1;\n        for (int i=1; i&lt;=n; i++)\n        {\n            if (s[i]!=w[i])\n            {\n                cout &lt;&lt;&quot;NO&quot;&lt;&lt;endl;\n                b=0;\n                break;\n            }\n        }\n        if (b==1)\n        {\n            cout &lt;&lt;&quot;YES&quot;&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"c-isamatdin-and-his-magic-wand\">C. Isamatdin and His Magic Wand!</h3>\n<p><strong>给定一串数，可以选定一个奇数一个偶数对数字进行交换，求若干次操作后数组能达到的最小字典序的状态。</strong></p><p>注意到如果这个数组含奇数和偶数，那么其实每两个数都是可以通过一个奇偶性不同的“媒介”来实现位置交换的。所以这道题其实就变成了判断数组，如果全奇或全偶则原样输出；否则直接排序后输出。因为这样的操作一定可以达到理论最小字典序。</p><pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int t,a[200010];\n    cin&gt;&gt;t;\n    for (int T=1; T&lt;=t; T++)\n    {\n        int n,b1=0,b2=0;\n        cin&gt;&gt;n;\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;a[i];\n            if (a[i]%2==0)\n            {\n                b2=1;\n            }\n            else\n            {\n                b1=1;\n            }\n        }\n        if (b2==1 &amp;&amp; b1==1)\n        {\n            sort(a+1,a+n+1);\n        }\n        for (int i=1; i&lt;=n; i++)\n            {\n                cout &lt;&lt;a[i]&lt;&lt;&#39; &#39;;\n            }\n        cout &lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"d-yet-another-array-problem\">D. Yet Another Array Problem</h3>\n<p><strong>给定一个数组，要求找出和其中至少一个数互质的数，输出符合条件的最小数。没有则输出-1</strong></p><p>虽然题目的范围给的很大 $( 2 \\leq x,a_i \\leq 10^{18} )$ ，但是再想一下不难发现前几十个质数相乘就已经远远超过这个大小了。（好像乘到57左右）那么，理论上这个题的答案也不会超过这个数。我是只处理了小于100的质数，后面就偏暴力枚举了，事实证明100以内就够了。\n所以应该就不存在不存在这样的数，最终输出-1的情况。<del>想搓组数据去hack的时候才察觉到这一点</del></p><pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    unsigned long long t,a[100010];\n    int b[110]={0};\n    cin&gt;&gt;t;\n    for (int i=3; i&lt;=100; i++)\n    {\n        for (int j=i-1; j&lt;=2; j++)\n        {\n            if (i%j==0)\n            {\n                b[i]=1;\n                break;\n            }\n        }\n    }\n    for (int T=1; T&lt;=t; T++)\n    {\n        int n,b1=0,b2=0;\n        cin&gt;&gt;n;\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;a[i];\n        }\n        int bb=0;\n        for (int i=2; i&lt;=100; i++)\n        {\n            if (b[i]==0)\n            {\n                for (int j=1; j&lt;=n; j++)\n              {\n                    if (gcd(i,a[j])==1)\n                    {\n                        cout &lt;&lt;i&lt;&lt;endl;\n                        bb=1;\n                        break;\n                    }\n                }\n            }\n            if (bb==1)\n            {\n                break;\n            }\n        }\n        if (bb==0)\n        {\n            cout &lt;&lt;-1&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"e-khba-loves-to-sleep\">E. khba Loves to Sleep!</h3>\n<p><strong>在$[0,x]$范围里，$n$个朋友分别位于位置$a_i$，要求选定$k$个位置，使这些朋友到达其中任何一个位置的最小距离最大。</strong></p><p>题目范围$1 \\leq n,k \\leq 2 \\cdot 10^5,k-1 \\leq x \\leq 10^9$，遍历一边整个范围的位置代价过于大了，$k$的不定导致没法从相邻朋友的距离这个方面入手。\n考虑二分答案（这里的“答案”即最大的最小距离），对于每个答案遍历一遍满足这个距离的时候，所有的可行位置$sum$，之后将其与$k$进行比较。$sum &lt; k$时说明目前答案已经不可行了，继续二分前半段更小的最小距离；$sum \\geq k$则说明当前答案可以，继续二分更大的答案。\n比赛的时候猪脑过载写了一堆好像也不用特判的判断。出D题才0:22，出这道题就1:24了。仅供参考，看前面的二分代码就行</p><pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int t,a[200010];\n    cin&gt;&gt;t;\n    for (int T=1; T&lt;=t; T++)\n    {\n        int n,k,x;\n        cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;a[i];\n        }\n        // if (n==1)//这是笨比特判，后来发现没用，别看\n        // {\n        //     int as;\n        //     if (abs(x-a[1]-a[1])&gt;=k)\n        //     {\n        //         as=min(x-a[1],a[1]);\n        //     }\n        //     else\n        //     as=min(x-a[1],a[1])-(k-abs(x-a[1]-a[1]))/2;\n        //     int aaa=0;\n        //     cout&lt;&lt;&quot;S&quot;&lt;&lt;as&lt;&lt;endl;\n        //     for (int i=0; i&lt;=x; i++)\n        //     {\n        //         if (i&lt;=a[1]-as+1  || i&gt;=a[1]+as-1)\n        //         {\n        //             if (aaa==k)\n        //             {\n        //                 break;\n        //             }\n        //             cout &lt;&lt;i&lt;&lt;&quot; &quot;;\n        //             aaa++;\n        //         }\n        //     }\n        //     cout &lt;&lt;endl;\n        //     break;\n        // }\n        sort (a+1,a+n+1);\n        int l=0,r=x+2;\n        int rr,br=0;\n        while (l&lt;=r)\n        {\n            int mid=(l+r)/2,ans=0;\n            if (a[1]-mid+1&gt;0)\n            {\n                ans+=a[1]-mid+1;\n            }\n            // cout &lt;&lt;l&lt;&lt;&#39;,&#39;&lt;&lt;r&lt;&lt;endl;\n            for (int i=2; i&lt;=n; i++)\n            {\n                // cout &lt;&lt;a[i]&lt;&lt;&quot;__&quot;&lt;&lt;a[i-1]&lt;&lt;&quot;:&quot;&lt;&lt;a[i]-mid+1-a[i-1]-mid&lt;&lt;endl;\n                if (a[i]-mid+1-a[i-1]-mid&gt;0)\n                {\n                    ans+=a[i]-mid+1-a[i-1]-mid;\n                }\n            }\n            if (x-a[n]-mid+1&gt;0)\n            {\n                ans+=x-a[n]-mid+1;\n            }\n            // cout &lt;&lt;&quot;**&quot;&lt;&lt;ans&lt;&lt;endl;\n            if (ans&gt;=k)\n            {\n                rr=mid;\n                if (l==r)\n            {\n                break;\n            }\n                if (r-l==1)\n                {\n                    br=1;\n                    l=r;\n                    continue;\n                }\n                l=mid;\n                continue;\n            }\n            if (l==r)\n            {\n                break;\n            }\n            r=mid;\n        }\n        // cout&lt;&lt;&quot;ANS=&quot;&lt;&lt;rr&lt;&lt;endl&lt;&lt;endl;\n        if (rr==0)\n        {\n            for (int i=0; i&lt;=k-1; i++)\n            {\n                cout &lt;&lt;i&lt;&lt;&#39; &#39;;\n            }\n            cout &lt;&lt;endl;\n            continue;\n        }\n            int aa=0;\n            if (a[1]-rr&gt;=0)\n            {\n                for (int j=0; j&lt;=a[1]-rr; j++)\n                {\n                    if (aa==k)\n                    {\n                        break;\n                    }\n                    cout &lt;&lt;j&lt;&lt;&#39; &#39;;\n                    aa++;\n                }\n            }\n            if (aa&lt;k)\n            {\n                for (int i=2; i&lt;=n; i++)\n            {\n                if (a[i]-rr+1-a[i-1]-rr&gt;0)\n                {\n                    for (int j=a[i-1]+rr; j&lt;=a[i]-rr; j++)\n                    {\n                        if (aa==k)\n                        {\n                            break;\n                        }\n                        cout &lt;&lt;j&lt;&lt;&#39; &#39;;\n                        aa++;\n                    }\n                }\n                if (aa==k)\n                        {\n                            break;\n                        }\n            }\n                if (aa&lt;k)\n                {\n                    if (x-a[n]-rr+1&gt;0)\n            {\n                for (int j=a[n]+rr; j&lt;=x; j++)\n                {\n                    if (aa==k)\n                    {\n                        break;\n                    }\n                    cout &lt;&lt;j&lt;&lt;&#39; &#39;;\n                    aa++;\n                }\n            }\n                }\n            }\n\n            cout &lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"f-tree-tree\">F. Tree, TREE!!!</h3>\n<p>等我钻研一下之后可能补上。枚举每个根节点的lca显然会超时，应该是树状dp之类的东西，但是我忘了咋写了</p><hr>\n<h3 id=\"g-mukhammadali-and-the-smooth-array\">G. Mukhammadali and the Smooth Array</h3>\n<p><strong>给定一个数组$a_n$，可以进行操作：消耗代价$c_i$，将$a_i$更改为任意数。求最小的代价，将整个数组变为不严格递增数列（即可以存在相等的数）。</strong></p><p>dp。定义dp数组$dp_i$为到如使$a_i$不变，到第$i$个位置为止，保证前面是不严格递增所<strong>节省的</strong>代价的<strong>最大值</strong>。\n实现：</p><ul>\n<li>先初始化$dp_i=c_i$，即初始不变$a_i$时节省的代价是$c_i$本身；</li>\n<li>枚举$i$。对于每个$i$，枚举所有$j&lt;i$，若有$a_j \\leq a_i$，则执行状态转移方程\n$$\ndp_i=max(dp_i,dp_j+c_i)\n$$\n意思大概就是$a_j \\leq a_i$时，$a_j$与$a_i$已经满足不严格递增，可以在到第$j$个位置为止节省的代价的基础上（即$dp_j$）再节省一个$c_i$，$dp_i$取从$j$转移过来的和它当时本身的最大值即可。</li>\n<li>取所有$dp_i$中的最大值$dp_{max}$。因为代价最小和节省的代价最大等价，输出$\\sum_{i=1}^{n} c_i-dp_{max}$即为最终答案。</li>\n</ul>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int t;\n    cin&gt;&gt;t;\n    for (int T=1; T&lt;=t; T++)\n    {\n        long long sum=0;\n        long long n,a[10000],c[10000],dp[10000];\n        cin&gt;&gt;n;\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;a[i];\n        }\n        for (int i=1; i&lt;=n; i++)\n        {\n            cin&gt;&gt;c[i];\n            sum+=c[i];\n            dp[i]=c[i];\n        }\n        for (int i=1; i&lt;=n; i++)\n        {\n            for (int j=1; j&lt;i; j++)\n            {\n                if (a[j]&lt;=a[i])\n                {\n                    dp[i]=max(dp[i],dp[j]+c[i]);\n                }\n            }\n        }\n        long long mx=-1;\n        for (int i=1; i&lt;=n; i++)\n        {\n            mx=max(mx,dp[i]);\n        }\n        // cout &lt;&lt;&quot;++&quot;;\n        cout &lt;&lt;sum-mx&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n",
            "author": {
                "name": "Syna"
            },
            "tags": [
            ],
            "date_published": "2025-11-02T18:37:42+08:00",
            "date_modified": "2025-11-02T19:58:05+08:00"
        }
    ]
}
